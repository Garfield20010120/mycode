#include<stdio.h>
//22.5.6数据存储2--原反补码unsigned char与整型提升的转换练习 
int main()
{
	//题1 
	unsigned char a=-1;
	printf("a=%d\n",a);//输出255
	//整型提升：10000000000000000000000000000001 (原)
	//1111111111111111111111111111110（反）
	//1111111111111111111111111111111（补）
	//实际存储在unsigned char中：11111111
	//打印int格式时：（原来为unsigned char故前面全补0）00000000000000000000000011111111（255）因为首字符是0所以直接打印 
	
	//题2 
	char b=-128;
	printf("b=%u\n",b);//输出4294967168
	//%u位unsigned int 
	//整型提升：10000000000000000000000010000000 原
	//11111111111111111111111101111111反
	//11111111111111111111111110000000补（4294967168） 
	//实际存储在char中 :10000000
	//打印unsigned int格式时（原来为char（有符号）首字符为1故前面全补1）：即为补码形式然后因为输出是unsigned所以直接打印：4294967168 
	
	//题3 
	char c = 128;
	printf("c=%d\n",c);//输出4294967168
	//整型提升：00000000000000000000000010000000 原
	//00000000000000000000000010000000正数原反补相同 
	//实际存储在char中 :10000000
	//打印unsigned int格式时（原来为char（有符号）首字符为1故前面全补1）：11111111111111111111111110000000然后因为输出是unsigned所以直接打印：4294967168 
	
	//题4 
	int d=-20;
	unsigned e=10;
	printf("e+d=%d\n",e+d);//输出：-10
	
	//题5 
	unsigned int i;
	for(i=9;i>=0;i--)
	{
		printf("%u\n",i);//死循环 （i是无符号数永远为正） 
	} 
	return 0;
}
